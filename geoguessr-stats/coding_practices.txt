TypeScript Best Practices for this Project:

1.  **Avoid `any` at all costs.** The `any` type opts out of type checking and defeats the purpose of TypeScript. Our build process has strict linting rules that will fail if `any` is used.

2.  **Define Specific Types.** Instead of using `any`, take the time to define a specific `interface` or `type` for your data structures.
    *   **Where to put them?** If a type is used by multiple components, define it in `lib/types.ts`. If it's only used within a single component, you can define it locally in that file.
    *   **Example:** Instead of `const data: any = ...`, define `interface MyData { id: number; name: string; }` and use `const data: MyData = ...`.

3.  **Leverage Existing Types.** For external libraries (like Leaflet or React), always try to use the types they provide. For example, Leaflet event handlers provide typed event objects. Use them.

4.  **Be Specific with Function Signatures.** Clearly type the parameters and return values of your functions.
    *   **Bad:** `function processData(data) { ... }`
    *   **Good:** `function processData(data: MyData): ProcessedData { ... }`

5.  **Use Utility Types.** TypeScript's built-in utility types like `Partial<T>`, `Pick<T, K>`, and `Omit<T, K>` are very powerful for creating new types from existing ones without duplicating code.

6.  **Log Solutions for Recurring Issues.** If you encounter a coding problem or a type error that takes significant time to debug and resolve, document the solution in this `coding_practices.txt` file. Explain the problem, the root cause, and the final solution. This will serve as a living guide to prevent repeating mistakes.

7.  **Inspect Data During Debugging.** When encountering unexpected behavior related to data, especially with external data sources or complex transformations, use `console.log` to inspect the data at various stages. This helps verify data format, content, and consistency with expected types. Remember to remove `console.log` statements before committing.

By following these simple rules, we can maintain a high level of code quality, prevent runtime errors, and ensure our builds don't fail due to linting issues.
