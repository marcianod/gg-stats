<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body { padding: 1rem; background-color: #f8f9fa; }
    #map { height: 600px; width: 100%; border-radius: 0.5rem; border: 1px solid #dee2e6; }
    .stat-card { text-align: center; }
    .match-row, .country-row { 
      cursor: pointer; 
      background-color: #f8f9fa; 
      transition: background-color 0.2s ease;
    }
    .match-row:hover, .country-row:hover { background-color: #e9ecef; }
    .match-row.expanded, .country-row.expanded { background-color: #e7f1ff; }
    .round-row { 
      background-color: #fff;
    }
    /* --- REDESIGNED: Round Delta View --- */
    .round-delta-card {
      padding: 0.6rem 0.6rem 0.6rem 1rem;
      border-left: 4px solid;
      margin-bottom: 0.5rem;
      background-color: #fff;
      border-radius: 0.25rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .round-delta-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }
    .round-delta-card.active {
        background-color: #e7f1ff;
        border-left-color: #0066cc;
    }
    .round-delta-card.win { border-left-color: #198754; }
    .round-delta-card.loss { border-left-color: #dc3545; }

    .collapsed-icon::before { content: "‚ñ∂ "; }
    .expanded-icon::before { content: "‚ñº "; color: #0066cc; }
    .round-details { padding-left: 1.5rem; }
    .round-stats { display: flex; gap: 0.75rem; align-items: center; margin: 0; flex-wrap: wrap; }
    .round-stat-box { 
      padding: 0.4rem 0.6rem; 
      background-color: #ffffff; 
      border-radius: 0.25rem; 
      border: 1px solid #e9ecef;
      flex: 1 1 0;
      min-width: 170px; /* Increased width */
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .round-stat-label { 
      font-size: 0.7rem; 
      color: #6c757d; 
      text-transform: uppercase; 
      margin-bottom: 0.15rem;
    }
    .round-stat-value { 
      font-size: 1rem; 
      font-weight: 600; 
      white-space: nowrap;
    }
    .score-comparison { 
      display: flex; 
      align-items: center; 
      gap: 0.5rem;
    }
    .my-score { color: #0066cc; }
    .opp-score { color: #dc3545; }
    .country-badge { font-size: 0.875rem; }
    .win-badge { background-color: #28a745; }
    .loss-badge { background-color: #dc3545; }
    .stats-summary { 
      background-color: white; 
      padding: 0.75rem; 
      border-radius: 0.5rem; 
      margin-bottom: 1rem; 
    }
    
    /* --- NEW TABLE STYLES --- */
    .table-construct {
      background-color: white;
      border-radius: 0.5rem;
      padding: 1rem;
      font-size: 0.95rem;
      max-height: 75vh; /* This container will scroll */
      overflow-y: auto;
      border: 1px solid #dee2e6;
    }
    .table-body {
      table-layout: fixed;
      width: 100%;
    }
    .table-body thead {
      position: sticky;
      top: -1rem; /* Counteract parent padding */
      background-color: white;
      z-index: 10;
    }
    .table-body th {
      border-bottom: 2px solid #dee2e6;
      padding: 0.5rem;
      cursor: pointer;
      user-select: none;
    }
    .table-body th:hover {
      background-color: #f8f9fa;
    }
    .table-body td {
      padding: 0.5rem;
    }
    .table-construct::-webkit-scrollbar { width: 8px; }
    .table-construct::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
    .table-construct::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
    .table-construct::-webkit-scrollbar-thumb:hover { background: #555; }
    
    .round-number-toggle { 
      cursor: pointer; 
      color: #0066cc; 
      text-decoration: none;
      position: relative;
      padding: 0.1rem 0.3rem;
      border-radius: 0.25rem;
      transition: all 0.2s ease;
    }
    .round-number-toggle:hover { color: #0052a3; background-color: #e9ecef; }
    .round-number-toggle::after { content: " üìç"; font-size: 0.8rem; transition: transform 0.2s ease; }
    .round-number-toggle:hover::after { transform: scale(1.2); }
    .round-number-toggle.map-open::after { content: " üó∫Ô∏è"; }
    .country-filter-btn { margin: 0.2rem; font-size: 0.8rem; padding: 0.25rem 0.5rem; }

    /* Sparkline and Delta Styles */
    .country-summary-card {
      background-color: #f8f9fa;
      padding: 1rem;
      border-top: 1px solid #dee2e6;
    }
    .sparkline-container {
        display: block; /* Changed from flex */
    }
    .sparkline {
      stroke: #0066cc;
      stroke-width: 1.5;
      fill: none;
    }
    .delta-win { color: #198754; }
    .delta-loss { color: #dc3545; }
    .delta-neutral { color: #6c757d; }
    .delta-value { font-size: 0.8em; font-weight: normal; }

    /* Confusion Matrix Styles */
    .confusion-matrix-container {
      background-color: white;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 1rem;
      overflow-x: auto;
    }
    .confusion-matrix {
      font-size: 0.85rem;
      border-collapse: collapse;
      width: 100%;
    }
    .confusion-matrix th,
    .confusion-matrix td {
      border: 1px solid #e9ecef;
      padding: 0.3rem;
      text-align: center;
      min-width: 50px;
    }
    .confusion-matrix th {
      background-color: #f8f9fa;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .confusion-matrix th:first-child {
      position: sticky;
      left: 0;
      z-index: 11;
      background-color: #f8f9fa;
    }
    .confusion-matrix td:first-child {
      position: sticky;
      left: 0;
      background-color: #f8f9fa;
      font-weight: 600;
      z-index: 9;
    }
    .confusion-cell {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .confusion-cell:hover {
      background-color: #e7f1ff !important;
      transform: scale(1.1);
    }
    .confusion-cell-0 { background-color: #ffffff; }
    .confusion-cell-1 { background-color: #fff5f5; }
    .confusion-cell-2 { background-color: #ffe4e4; }
    .confusion-cell-3 { background-color: #ffd4d4; }
    .confusion-cell-4 { background-color: #ffc4c4; }
    .confusion-cell-5 { background-color: #ffb3b3; }
    .confusion-cell-high { background-color: #ff9999; }
    .confusion-summary {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 0.5rem;
    }
    .confusion-stat {
      display: inline-block;
      margin: 0.5rem 1rem 0.5rem 0;
    }

    @media (max-width: 1399px) {
      .round-stats { font-size: 0.875rem; }
      .round-stat-box { padding: 0.3rem 0.5rem; }
    }
    @media (max-width: 1199px) { #map { height: 500px; } }
    @media (max-width: 991px) {
      #map { height: 400px; margin-bottom: 1rem; }
      .table-construct { max-height: 60vh; }
    }
    
    .custom-marker-icon {
      background: transparent;
      border: none;
    } 

  </style>
</head>
<body>
  <div class="container-fluid">
    <div id="error-container" class="d-none"></div>
    
    <div id="dashboard-container" class="d-none">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h1 class="mb-0">GeoGuessr Duel Stats</h1>
      </div>
      
      <div class="row">
        <!-- Main Content Column -->
        <div class="col-xl-8 col-lg-7">
          
          <!-- TABS for view switching -->
          <ul class="nav nav-tabs" id="viewTabs" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="country-tab" data-bs-toggle="tab" data-bs-target="#country-view" type="button" role="tab">By Country</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="matches-tab" data-bs-toggle="tab" data-bs-target="#matches-view" type="button" role="tab">Recent Matches</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis-view" type="button" role="tab">Advanced Analysis</button>
            </li>
          </ul>

          <div class="tab-content" id="viewTabsContent">
            <!-- COUNTRY VIEW (REFACTORED) -->
            <div class="tab-pane fade show active" id="country-view" role="tabpanel">
              <div class="table-construct">
                <table class="table table-hover table-body">
                  <colgroup>
                    <col style="width: 5%;">
                    <col style="width: 30%;">
                    <col style="width: 15%;">
                    <col style="width: 20%;">
                    <col style="width: 20%;">
                    <col style="width: 10%;">
                  </colgroup>
                  <thead>
                    <tr>
                      <th></th>
                      <th onclick="setCountrySort('name')">Country</th>
                      <th onclick="setCountrySort('winRate')">Win Rate</th>
                      <th onclick="setCountrySort('avgScoreDelta')">Avg. Score Œî</th>
                      <th onclick="setCountrySort('totalScoreDelta')">Total Score Œî</th>
                      <th onclick="setCountrySort('totalRounds')">Rounds</th>
                    </tr>
                  </thead>
                  <tbody id="country-table-body"></tbody>
                </table>
              </div>
            </div>

            <!-- MATCHES VIEW (REFACTORED) -->
            <div class="tab-pane fade" id="matches-view" role="tabpanel">
              <div class="table-construct mt-2">
                <table class="table table-hover table-body">
                  <colgroup>
                    <col style="width: 5%;">
                    <col style="width: 12%;">
                    <col style="width: 20%;">
                    <col style="width: 10%;">
                    <col style="width: 15%;">
                    <col style="width: 8%;">
                    <col style="width: 20%;">
                    <col style="width: 10%;">
                  </colgroup>
                  <thead>
                    <tr>
                      <th></th>
                      <th>Date</th>
                      <th>Map</th>
                      <th>Result</th>
                      <th>Final Score</th>
                      <th>Mode</th>
                      <th>Countries</th>
                      <th># Rounds</th>
                    </tr>
                  </thead>
                  <tbody id="matches-table-body"></tbody>
                </table>
              </div>
            </div>

            <!-- ADVANCED ANALYSIS VIEW -->
            <div class="tab-pane fade" id="analysis-view" role="tabpanel">
              <div class="confusion-matrix-container">
                <h4 class="mb-3">Country Confusion Matrix</h4>
                <p class="text-muted">This matrix shows which countries you confuse with each other. Each cell shows how many times you guessed the column country when it was actually the row country.</p>
                <div class="confusion-summary" id="confusion-summary">
                  <!-- Summary stats will be inserted here -->
                </div>
                <div style="overflow-x: auto; max-height: 600px; overflow-y: auto;">
                  <table class="confusion-matrix" id="confusion-matrix">
                    <!-- Matrix will be inserted here -->
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Map Column -->
        <div class="col-xl-4 col-lg-5">
          <div class="stats-summary">
            <h5 class="mb-3">World Map</h5>
            <div id="map"></div>
            <p class="text-muted small mt-2">Click a country on map or a round number in the table to see details.</p>
          </div>
        </div>
      </div>
    </div>
  </div>

<?!= '<script> var serverData = ' + dataFromServer + '; var geoJsonFromServer = ' + geoJsonData + '; var timestamp = ' + timestamp + '; </script>' ?>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src='https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js'></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
  // =================================================================
  // === ACTION REQUIRED: PASTE YOUR GEOGUESSR PLAYER ID BELOW      ===
  // =================================================================
  const MY_PLAYER_ID = '608a7f9394d95300015224ac';
  // =================================================================

  // =================================================================
  // === Data Cleanup Configuration ==================================
  // =================================================================
  const countryBlacklist = new Set([
    'Scarborough Reef',
    'Spratly Islands',
    'Bajo Nuevo Bank',
    'Serranilla Bank',
    'Bajo Nuevo Bank (Petrel Is.)',
    'Ashmore and Cartier Islands'
  ]);

  const territoryCorrections  = {
    'IL': { 'SY': 'IL' }, 
    'HK': { 'CN': 'HK' }, 
    'PS': { 'IL': 'PS' },
    'TW': { 'CN': 'TW' }
  };
  // =================================================================

  let allDuels = [];
  let processedDuels = [];
  let countryStats = {};
  let countryNames = {};
  let globalAvgStdDev = 0;
  let map, geojsonLayer, geojsonData;
  let confusionMatrix = {};
  
  let expandedMatches = new Set();
  let expandedCountries = new Set(); 
  
  let currentRoundLayerGroup = null; 
  let currentOpenMapId = null;
  let countrySortState = { column: 'totalRounds', direction: 'desc' };
  
  let roundDataCache = {};

  // =================================================================
  // === Custom Map Marker Icons =====================================
  // =================================================================
  function createPlayerIcon(color) {
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32">
        <path fill="${color}" stroke="#FFFFFF" stroke-width="1.5" d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"></path>
        <circle cx="12" cy="9" r="2.5" fill="#FFFFFF"></circle>
      </svg>`;
    return new L.DivIcon({
      html: svg,
      className: 'custom-marker-icon',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -34]
    });
  }

  const correctLocationIcon = new L.DivIcon({
    html: `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32">
        <path fill="#28a745" stroke="#FFFFFF" stroke-width="1.5" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path>
      </svg>`,
    className: 'custom-marker-icon',
    iconSize: [32, 32],
    iconAnchor: [5, 32],
    popupAnchor: [6, -30]
  });

  const myIcon = createPlayerIcon('#0d6efd');
  const oppIcon = createPlayerIcon('#dc3545');
  // =================================================================
  // === End of New Icons ============================================
  // =================================================================

  document.addEventListener("DOMContentLoaded", async function() {
    console.log('App loaded at:', new Date(timestamp).toISOString());
    
    if (MY_PLAYER_ID === 'PASTE_YOUR_ID_HERE') return showError('<strong>Action Required:</strong> Please set `MY_PLAYER_ID`.');
    
    try {
      let rawDataFromServer;
      let metadata = null;

      if (serverData && typeof serverData === 'object' && !Array.isArray(serverData) && serverData.data) {
          rawDataFromServer = serverData.data || [];
          metadata = serverData.metadata || {};
      } else {
          rawDataFromServer = serverData;
      }
      
      if (metadata) {
        console.log('File Metadata:', metadata);
        const debugInfo = document.createElement('div');
        debugInfo.className = 'alert alert-info small mb-2';
        debugInfo.innerHTML = `
          <strong>Debug Info:</strong> 
          Loaded from file: ${metadata.fileId || 'N/A'} | 
          Last Updated: ${metadata.lastUpdated ? new Date(metadata.lastUpdated).toLocaleString() : 'Unknown'}
        `;
        document.getElementById('dashboard-container').insertBefore(debugInfo, document.getElementById('dashboard-container').firstChild);
      }
      
      let flattenedData = [];
      if (Array.isArray(rawDataFromServer)) {
          flattenedData = rawDataFromServer.flat(Infinity);
      }

      allDuels = [];
      if (Array.isArray(flattenedData)) {
          flattenedData.forEach(item => {
              if (item && item.gameId) {
                  allDuels.push(item);
              }
          });
      }

      if (!allDuels || allDuels.length === 0) {
        return showError("No valid duel data found. Play a duel to sync.");
      }
      
      document.getElementById('dashboard-container').classList.remove('d-none');
      
      const seenGameIds = new Set();
      const uniqueDuels = [];
      for (const duel of allDuels) {
          if (duel && duel.gameId && !seenGameIds.has(duel.gameId)) {
              seenGameIds.add(duel.gameId);
              uniqueDuels.push(duel);
          }
      }
      
      uniqueDuels.sort((a, b) => new Date(b.startTime || b.created || 0) - new Date(a.startTime || a.created || 0));
      allDuels = uniqueDuels;

      console.log(`Loaded and processed a total of ${allDuels.length} unique duels.`);
      
      await initMap();
      processDuelData();
      calculateConfusions();
    } catch (e) {
      console.error("Init Error:", e);
      showError(`A critical error occurred: ${e.message}`);
    }
  });

function processDuelData() {
    processedDuels = [];
    countryStats = {};
    confusionMatrix = {};
    roundDataCache = {};
    let allScores = [];
    let skippedCount = 0;

    allDuels.forEach((duel, index) => {
        if (!duel.teams || !duel.rounds || !duel.options || duel.rounds.length === 0) {
            skippedCount++;
            return;
        }

        const meTeam = duel.teams.find(t => t.players[0]?.playerId === MY_PLAYER_ID);
        const opponentTeam = duel.teams.find(t => t.players[0]?.playerId !== MY_PLAYER_ID);

        if (!meTeam || !opponentTeam) {
            skippedCount++;
            return;
        }

        const mePlayer = meTeam.players[0];
        const opponentPlayer = opponentTeam.players[0];

        if (!mePlayer?.guesses || !opponentPlayer?.guesses) {
            skippedCount++;
            return;
        }
        const gameMode = getGameMode(duel.options.movementOptions);
        const isWin = duel.result.winningTeamId === meTeam.id;
        let myTotalScore = 0, opponentTotalScore = 0;
        const countriesInDuel = new Set(), roundsData = [];

        duel.rounds.forEach((round) => {
            if (!round.panorama?.countryCode) return;
            const myGuess = mePlayer.guesses.find(g => g.roundNumber === round.roundNumber);
            const opponentGuess = opponentPlayer.guesses.find(g => g.roundNumber === round.roundNumber);
            if (!myGuess || !opponentGuess) return;
            
            const countryCode = round.panorama.countryCode.toUpperCase();
            countriesInDuel.add(countryCode);
            myTotalScore += myGuess.score;
            opponentTotalScore += opponentGuess.score;
            allScores.push(myGuess.score);
            
            const guessTime = (new Date(myGuess.created) - new Date(round.startTime)) / 1000;
            const opponentGuessTime = (new Date(opponentGuess.created) - new Date(round.startTime)) / 1000;
            const opponentDistance = turf.distance(
              turf.point([opponentGuess.lng, opponentGuess.lat]),
              turf.point([round.panorama.lng, round.panorama.lat]),
              { units: 'meters' }
            );

            if (!countryStats[countryCode]) {
                countryStats[countryCode] = { name: countryNames[countryCode] || countryCode, wins: 0, losses: 0, totalRounds: 0, totalScore: 0, totalScoreDelta: 0, totalDistDelta: 0, rounds: [], confusions: {} };
            }
            
            const scoreDelta = myGuess.score - opponentGuess.score;
            countryStats[countryCode].totalRounds++;
            countryStats[countryCode].totalScore += myGuess.score;
            countryStats[countryCode].totalScoreDelta += scoreDelta;
            countryStats[countryCode].totalDistDelta += myGuess.distance - opponentDistance;
            if (myGuess.score > opponentGuess.score) countryStats[countryCode].wins++; else countryStats[countryCode].losses++;
            
            const roundInfo = { 
                duelId: duel.gameId, 
                roundNumber: round.roundNumber, 
                date: new Date(round.startTime), 
                countryCode: countryCode, 
                myGuess: { lat: myGuess.lat, lng: myGuess.lng, score: myGuess.score, distance: myGuess.distance }, 
                opponentGuess: { lat: opponentGuess.lat, lng: opponentGuess.lng, score: opponentGuess.score, distance: opponentDistance }, 
                actual: { lat: round.panorama.lat, lng: round.panorama.lng, heading: round.panorama.heading, pitch: round.panorama.pitch, zoom: round.panorama.zoom }, 
                guessTime: guessTime, 
                opponentGuessTime: opponentGuessTime, 
                won: myGuess.score > opponentGuess.score, 
                scoreDelta: scoreDelta, 
                distDelta: myGuess.distance - opponentDistance, 
                timeDelta: guessTime - opponentGuessTime,
                myPlayerId: mePlayer.playerId,
                opponentPlayerId: opponentPlayer.playerId
            };
            roundsData.push(roundInfo);
            countryStats[countryCode].rounds.push(roundInfo);
        });

        if (roundsData.length === 0) return;

        processedDuels.push({ duelId: duel.gameId, date: roundsData[0].date, mapName: duel.options.map?.name || 'Unknown Map', mode: gameMode, isWin: isWin, myScore: myTotalScore, opponentScore: opponentTotalScore, countries: Array.from(countriesInDuel), rounds: roundsData });
    });

    if (allScores.length > 0) {
        const globalMean = allScores.reduce((a, b) => a + b, 0) / allScores.length;
        globalAvgStdDev = Math.sqrt(allScores.map(x => Math.pow(x - globalMean, 2)).reduce((a, b) => a + b) / allScores.length);
    }
    
    console.log(`Processing complete. Total duels: ${allDuels.length}. Processed: ${processedDuels.length}, Skipped: ${skippedCount}`);
}

function calculateConfusions() {
    if (typeof turf === 'undefined' || !geojsonData || !geojsonData.features) { return; }

    const PROXIMITY_THRESHOLD_KM = 20;

    const getCountryFromCoords = (lng, lat) => {
        try {
            const point = turf.point([lng, lat]);
            for (const feature of geojsonData.features) {
                if (!feature.geometry) continue;
                if (turf.booleanPointInPolygon(point, feature.geometry)) {
                    return feature.properties['ISO3166-1-Alpha-2'];
                }
            }
        } catch (e) { console.error("Error in getCountryFromCoords:", e); }
        return null;
    };

    confusionMatrix = {};
    Object.values(countryStats).forEach(stats => stats.confusions = {});

    Object.values(countryStats).forEach(stats => {
        stats.rounds.forEach(round => {
            const actualCountry = round.countryCode;
            let guessedCountryCode = getCountryFromCoords(round.myGuess.lng, round.myGuess.lat);

            if (guessedCountryCode && guessedCountryCode !== actualCountry) {
                const territoryCorrection = territoryCorrections[actualCountry]?.[guessedCountryCode];
                if (territoryCorrection) {
                    guessedCountryCode = territoryCorrection;
                } else {
                    const distance = turf.distance(turf.point([round.actual.lng, round.actual.lat]), turf.point([round.myGuess.lng, round.myGuess.lat]), { units: 'kilometers' });
                    if (distance < PROXIMITY_THRESHOLD_KM) {
                        guessedCountryCode = actualCountry;
                    }
                }
            }

            const guessedCountry = guessedCountryCode || actualCountry;

            if (guessedCountryCode && guessedCountryCode !== actualCountry) {
                stats.confusions[guessedCountryCode] = (stats.confusions[guessedCountryCode] || 0) + 1;
            }
            
            if (!confusionMatrix[actualCountry]) confusionMatrix[actualCountry] = {};
            confusionMatrix[actualCountry][guessedCountry] = (confusionMatrix[actualCountry][guessedCountry] || 0) + 1;
        });
    });
    
    updateDisplay();
}

  function updateDisplay() {
    renderCountryView();
    renderMatchesView();
    if (Object.keys(confusionMatrix).length > 0) {
      renderAdvancedAnalysis();
    } else {
      document.getElementById('confusion-summary').innerHTML = `<div class="alert alert-info">No confusion data available.</div>`;
      document.getElementById('confusion-matrix').innerHTML = '';
    }
    updateMapColors();
  }

  function renderCountryView() {
    const tbody = document.getElementById('country-table-body');
    tbody.innerHTML = '';
    
    const sortedCountries = Object.entries(countryStats).sort((a, b) => {
        const aStats = a[1], bStats = b[1];
        let valA, valB;
        switch(countrySortState.column) {
            case 'name': valA = aStats.name; valB = bStats.name; break;
            case 'winRate': valA = aStats.wins / aStats.totalRounds; valB = bStats.wins / bStats.totalRounds; break;
            case 'avgScoreDelta': valA = aStats.totalScoreDelta / aStats.totalRounds; valB = bStats.totalScoreDelta / bStats.totalRounds; break;
            default: valA = aStats[countrySortState.column]; valB = bStats[countrySortState.column];
        }
        if (typeof valA === 'string') return countrySortState.direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
        return countrySortState.direction === 'asc' ? valA - valB : valB - valA;
    });

    sortedCountries.forEach(([code, stats]) => {
      const isExpanded = expandedCountries.has(code);
      const winRate = (stats.wins / stats.totalRounds * 100).toFixed(1);
      const avgScoreDelta = stats.totalScoreDelta / stats.totalRounds;

      const countryRow = tbody.insertRow();
      countryRow.className = `country-row ${isExpanded ? 'expanded' : ''}`;
      countryRow.onclick = () => toggleCountry(code);
      countryRow.innerHTML = `
        <td><span class="${isExpanded ? 'expanded-icon' : 'collapsed-icon'}"></span></td>
        <td>${getFlagEmoji(code)} <strong>${stats.name}</strong></td>
        <td>${winRate}%</td>
        <td class="${avgScoreDelta >= 0 ? 'delta-win' : 'delta-loss'}">${avgScoreDelta >= 0 ? '+' : ''}${avgScoreDelta.toFixed(0)}</td>
        <td class="${stats.totalScoreDelta >= 0 ? 'delta-win' : 'delta-loss'}">${stats.totalScoreDelta >= 0 ? '+' : ''}${stats.totalScoreDelta.toLocaleString()}</td>
        <td>${stats.totalRounds}</td>
      `;

      if (isExpanded) {
        const summaryRow = tbody.insertRow();
        summaryRow.className = 'round-row';
        const cell = summaryRow.insertCell();
        cell.colSpan = 6;
        
        let confusionsContent = '<div class="round-stat-value text-muted" style="font-size: 0.9rem;">None</div>';
        if (stats.confusions && Object.keys(stats.confusions).length > 0) {
          const sortedConfusions = Object.entries(stats.confusions).sort((a, b) => b[1] - a[1]).slice(0, 3);
          confusionsContent = sortedConfusions.map(([c, count]) => `<div style="white-space: nowrap; font-size: 0.9rem; margin-top: 0.2rem;">${getFlagEmoji(c)} ${countryNames[c] || c} <span class="text-muted">(${count})</span></div>`).join('');
        }
        
        const scoreDeltas = stats.rounds.map(r => r.scoreDelta).slice(-30);
        const absoluteScores = stats.rounds.map(r => r.myGuess.score).slice(-30);
        const sparklineSvg = createSparkline(scoreDeltas, absoluteScores);

        const scores = stats.rounds.map(r => r.myGuess.score);
        const mean = stats.totalScore / stats.totalRounds;
        const stdDev = Math.sqrt(scores.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / stats.totalRounds);
        const consistency = getConsistencyRating(stdDev, globalAvgStdDev);
        const potential5k = (scores.filter(s => s >= 4500).length / stats.totalRounds * 100).toFixed(1);

        cell.innerHTML = `
          <div class="country-summary-card">
            <div class="row align-items-center">
              <div class="col-md-4">
                <div class="round-stat-box w-100"><div class="round-stat-label">Consistency</div><div class="round-stat-value">${stdDev.toLocaleString(undefined, {maximumFractionDigits: 0})} <span class="delta-value">(${consistency})</span></div></div>
                <div class="round-stat-box w-100 mt-2"><div class="round-stat-label">5k Potential</div><div class="round-stat-value">${potential5k}%</div></div>
                <div class="round-stat-box w-100 mt-2"><div class="round-stat-label">Often Confused With</div>${confusionsContent}</div>
              </div>
              <div class="col-md-8">
                <div class="round-stat-label">Score Delta Trend (Last ${scoreDeltas.length} Rounds)</div>
                <div class="sparkline-container">${sparklineSvg}</div>
              </div>
            </div>
            <div style="padding-top: 1rem;">
              ${stats.rounds.sort((a,b) => b.date - a.date).map(round => renderRoundDeltaView(round)).join('')}
            </div>
          </div>`;
      }
    });
  }

  function renderRoundDeltaView(round) {
    const mapId = `${round.duelId}-${round.roundNumber}`;
    roundDataCache[mapId] = round;

    const scoreDelta = round.scoreDelta;
    const distDelta = round.distDelta / 1000;
    const timeDelta = round.timeDelta;

    const scoreClass = scoreDelta >= 0 ? 'delta-win' : 'delta-loss';
    const distClass = distDelta <= 0 ? 'delta-win' : 'delta-loss';
    const timeClass = timeDelta <= 0 ? 'delta-win' : 'delta-loss';

    let streetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${round.actual.lat},${round.actual.lng}`;
    if (round.actual.heading !== undefined) {
        streetViewUrl += `&heading=${round.actual.heading}`;
    }
    if (round.actual.pitch !== undefined) {
        streetViewUrl += `&pitch=0`;
    }

    return `
      <div id="round-card-${mapId}" class="round-delta-card ${round.won ? 'win' : 'loss'}" onclick="event.stopPropagation(); toggleRoundMap('${mapId}', this)">
        <div class="d-flex align-items-center justify-content-between flex-wrap">
            <div class="d-flex align-items-center flex-grow-1">
              <div class="me-3"><span class="badge bg-secondary">${getFlagEmoji(round.countryCode)} ${round.countryCode}</span></div>
              <div class="me-3 text-muted" style="font-size: 0.8rem;">${round.date.toLocaleDateString()}</div>
            </div>
            <div class="ms-auto">
                <a href="${streetViewUrl}" target="_blank" onclick="event.stopPropagation()" class="btn btn-sm btn-outline-secondary py-0 px-1" title="Open in Google Street View">üîó</a>
            </div>
        </div>
        <div class="round-stats mt-2">
          <div class="round-stat-box">
            <div class="round-stat-label">Score</div>
            <div class="round-stat-value">${round.myGuess.score.toLocaleString()} <span class="delta-value ${scoreClass}">(${scoreDelta >= 0 ? '+' : ''}${scoreDelta.toLocaleString()})</span></div>
          </div>
          <div class="round-stat-box">
            <div class="round-stat-label">Distance</div>
            <div class="round-stat-value">${(round.myGuess.distance/1000).toFixed(1)}km <span class="delta-value ${distClass}">(${distDelta <= 0 ? '' : '+'}${distDelta.toFixed(1)}km)</span></div>
          </div>
          <div class="round-stat-box">
            <div class="round-stat-label">Time</div>
            <div class="round-stat-value">${round.guessTime.toFixed(1)}s <span class="delta-value ${timeClass}">(${timeDelta <= 0 ? '' : '+'}${timeDelta.toFixed(1)}s)</span></div>
          </div>
        </div>
      </div>
    `;
  }
  
function renderMatchesView() {
    const tbody = document.getElementById('matches-table-body');
    tbody.innerHTML = '';
    processedDuels.forEach(duel => {
        const isExpanded = expandedMatches.has(duel.duelId);
        const matchRow = tbody.insertRow();
        matchRow.className = `match-row ${isExpanded ? 'expanded' : ''}`;
        matchRow.onclick = () => toggleMatch(duel.duelId);
        matchRow.innerHTML = `
            <td><span class="${isExpanded ? 'expanded-icon' : 'collapsed-icon'}"></span></td>
            <td>${duel.date.toLocaleDateString()}</td>
            <td>${duel.mapName}</td>
            <td><span class="badge ${duel.isWin ? 'win-badge' : 'loss-badge'}">${duel.isWin ? 'WIN' : 'LOSS'}</span></td>
            <td>${duel.myScore.toLocaleString()} - ${duel.opponentScore.toLocaleString()}</td>
            <td>${duel.mode.toUpperCase()}</td>
            <td>${duel.countries.map(c => `<span class="badge bg-secondary country-badge">${getFlagEmoji(c)} ${c}</span>`).join(' ')}</td>
            <td>${duel.rounds.length}</td>
        `;
        
        if (isExpanded) {
            const detailsRow = tbody.insertRow();
            detailsRow.className = 'round-row';
            const detailsCell = detailsRow.insertCell();
            detailsCell.colSpan = 8;
            detailsCell.innerHTML = `<div style="padding: 0.5rem 1rem;">${duel.rounds.sort((a, b) => a.roundNumber - b.roundNumber).map(round => renderRoundDeltaView(round)).join('')}</div>`;
        }
    });
}

  function renderAdvancedAnalysis() {
    if (!confusionMatrix || Object.keys(confusionMatrix).length === 0) return;
    
    let totalConfusions = 0;
    let mostConfusedPairs = [];
    Object.entries(confusionMatrix).forEach(([actual, guesses]) => {
        Object.entries(guesses).forEach(([guessed, count]) => {
            if (actual !== guessed) {
                totalConfusions += count;
                mostConfusedPairs.push({ actual, guessed, count, actualName: countryNames[actual] || actual, guessedName: countryNames[guessed] || guessed });
            }
        });
    });
    
    mostConfusedPairs.sort((a, b) => b.count - a.count);
    const top5Confusions = mostConfusedPairs.slice(0, 5);
    
    const summaryDiv = document.getElementById('confusion-summary');
    if (totalConfusions === 0) {
      summaryDiv.innerHTML = `<div class="alert alert-success"><h6>Perfect Accuracy!</h6><p class="mb-0">You have no country confusions.</p></div>`;
    } else {
      summaryDiv.innerHTML = `
        <div class="row">
            <div class="col-md-6"><h6>Overview</h6><div class="confusion-stat"><strong>Total Confusions:</strong> ${totalConfusions}</div></div>
            <div class="col-md-6"><h6>Top 5 Most Confused Pairs</h6>${top5Confusions.map(pair => `<div class="confusion-stat d-block">${getFlagEmoji(pair.actual)} ${pair.actualName} ‚Üí ${getFlagEmoji(pair.guessed)} ${pair.guessedName} <span class="badge bg-danger">${pair.count}</span></div>`).join('')}</div>
        </div>`;
    }
    
    const matrixTable = document.getElementById('confusion-matrix');
    const allCountries = Array.from(new Set(Object.keys(confusionMatrix).concat(...Object.values(confusionMatrix).map(Object.keys)))).sort((a, b) => (countryStats[b]?.totalRounds || 0) - (countryStats[a]?.totalRounds || 0));
    
    let headerHTML = '<thead><tr><th>Actual‚Üì/Guessed‚Üí</th>';
    allCountries.forEach(code => headerHTML += `<th title="${countryNames[code] || code}">${getFlagEmoji(code)}</th>`);
    headerHTML += '</tr></thead>';
    
    let bodyHTML = '<tbody>';
    allCountries.forEach(actualCode => {
        bodyHTML += `<tr><td>${getFlagEmoji(actualCode)} ${countryNames[actualCode] || actualCode}</td>`;
        allCountries.forEach(guessedCode => {
            const count = confusionMatrix[actualCode]?.[guessedCode] || 0;
            const cellClass = count === 0 ? 'confusion-cell-0' : count > 5 ? 'confusion-cell-high' : `confusion-cell-${count}`;
            const bgColor = actualCode === guessedCode ? 'background-color: #d4edda;' : '';
            bodyHTML += `<td class="confusion-cell ${cellClass}" style="${bgColor}" title="${countryNames[actualCode]} ‚Üí ${countryNames[guessedCode]}: ${count} times">${count || '-'}</td>`;
        });
        bodyHTML += '</tr>';
    });
    bodyHTML += '</tbody>';
    
    matrixTable.innerHTML = headerHTML + bodyHTML;
  }

  function toggleMatch(duelId) {
    if (expandedMatches.has(duelId)) expandedMatches.delete(duelId);
    else expandedMatches.add(duelId);
    renderMatchesView();
  }

  function toggleCountry(code) {
    const wasOpen = expandedCountries.has(code);
    expandedCountries.clear();
    if (!wasOpen) expandedCountries.add(code);
    renderCountryView();
  }
  
  function setCountrySort(column) {
    if (countrySortState.column === column) {
        countrySortState.direction = countrySortState.direction === 'asc' ? 'desc' : 'asc';
    } else {
        countrySortState.column = column;
        countrySortState.direction = 'desc';
    }
    renderCountryView();
  }

  window.toggleRoundMap = function(mapId, element) {
    const roundData = roundDataCache[mapId];
    if (!roundData) {
      console.error("Could not find round data for mapId:", mapId);
      return;
    }

    if (currentRoundLayerGroup) map.removeLayer(currentRoundLayerGroup);
    document.querySelector('.round-delta-card.active')?.classList.remove('active');

    if (currentOpenMapId === mapId) {
      currentOpenMapId = null;
      map.setView([20, 0], 2);
      return;
    }

    element.classList.add('active');

    // --- REPLAY LINK LOGIC ---
    const myReplayUrl = `https://www.geoguessr.com/duels/${roundData.duelId}/replay?player=${roundData.myPlayerId}&round=${roundData.roundNumber}&step=0`;
    const oppReplayUrl = `https://www.geoguessr.com/duels/${roundData.duelId}/replay?player=${roundData.opponentPlayerId}&round=${roundData.roundNumber}&step=0`;
    let actualStreetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${roundData.actual.lat},${roundData.actual.lng}`;
    
    if (roundData.actual.heading !== undefined) actualStreetViewUrl += `&heading=${roundData.actual.heading}`;
    if (roundData.actual.pitch !== undefined) actualStreetViewUrl += `&pitch=0`;

    const actualMarker = L.marker(roundData.actual, { icon: correctLocationIcon })
      .on('click', () => window.open(actualStreetViewUrl, '_blank'));

    const myMarker = L.marker(roundData.myGuess, { icon: myIcon })
      .on('click', () => window.open(myReplayUrl, '_blank'));
      
    const oppMarker = L.marker(roundData.opponentGuess, { icon: oppIcon })
      .on('click', () => window.open(oppReplayUrl, '_blank'));

    const myLine = L.polyline([roundData.myGuess, roundData.actual], {color: 'blue', dashArray: '5, 5'});
    const oppLine = L.polyline([roundData.opponentGuess, roundData.actual], {color: 'red', dashArray: '5, 5'});
    
    currentRoundLayerGroup = L.featureGroup([actualMarker, myMarker, oppMarker, myLine, oppLine]).addTo(map);
    map.fitBounds(currentRoundLayerGroup.getBounds().pad(0.2));
    currentOpenMapId = mapId;
  }

  function getScoreColor(score) {
    if (score > 4500) return '#1a9641';
    if (score > 3500) return '#a6d96a';
    if (score > 2500) return '#ffffbf';
    if (score > 1500) return '#fdae61';
    return '#d7191c';
  }

  function getConsistencyRating(stdDev, globalAvg) {
    if (stdDev < globalAvg * 0.75) return "Very Consistent";
    if (stdDev < globalAvg * 1.25) return "Consistent";
    return "Inconsistent";
  }

  function createSparkline(deltas, scores) {
    if (!deltas || deltas.length < 2) return '<svg width="100%" height="60"></svg>';
    const width = 200, height = 60, padding = 5;
    const maxDelta = Math.max(...deltas.map(d => Math.abs(d)), 1);
    
    const points = deltas.map((d, i) => `${(width/(deltas.length-1))*i},${(height/2)-(d/maxDelta)*(height/2-padding)}`).join(' ');
    const circles = scores.map((score, i) => `<circle cx="${(width/(deltas.length-1))*i}" cy="${(height/2)-(deltas[i]/maxDelta)*(height/2-padding)}" r="2.5" fill="${getScoreColor(score)}" stroke="white" stroke-width="0.5" />`).join('');

    return `
      <svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
        <line x1="0" y1="${height/2}" x2="${width}" y2="${height/2}" stroke="#e9ecef" stroke-width="1" />
        <polyline class="sparkline" points="${points}"/>
        ${circles}
      </svg>
    `;
  }

async function initMap() {
    map = L.map('map').setView([20, 0], 2);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO' }).addTo(map);

    if (typeof geoJsonFromServer === 'undefined' || (typeof geoJsonFromServer === 'object' && geoJsonFromServer.error)) {
        const errorMessage = geoJsonFromServer ? geoJsonFromServer.error : 'GeoJSON map data not loaded from server.';
        console.error(errorMessage);
        return showError(`Failed to load map data: ${errorMessage}`);
    }

    geojsonData = geoJsonFromServer;
    
    geojsonData.features = geojsonData.features.filter(feature => !countryBlacklist.has(feature.properties.name));

    geojsonData.features.forEach(feature => {
        const code = feature.properties['ISO3166-1-Alpha-2'];
        if (code && code !== '-99') {
          countryNames[code] = feature.properties.name;
        }
    });

    geojsonLayer = L.geoJson(geojsonData, {
        style: feature => ({ fillColor: getColorForFeature(feature), weight: 1, opacity: 1, color: 'white', fillOpacity: 0.85 }),
        onEachFeature: (feature, layer) => {
            const code = feature.properties['ISO3166-1-Alpha-2'];
            if (code && countryNames[code]) {
                layer.bindPopup(`<strong>${countryNames[code]}</strong>`);
                layer.on('click', () => {
                    document.getElementById('country-tab').click();
                    Array.from(document.querySelectorAll('#country-table-body tr.country-row'))
                      .find(row => row.cells[1]?.innerText.includes(countryNames[code]))
                      ?.scrollIntoView({behavior: 'smooth', block: 'center'});
                });
            }
        }
    }).addTo(map);
}

function updateMapColors() {
    if (!geojsonLayer) return;
    geojsonLayer.eachLayer(layer => {
        layer.setStyle({ fillColor: getColorForFeature(layer.feature), weight: 1, opacity: 1, color: 'white', fillOpacity: 0.85 });
        const code = layer.feature.properties['ISO3166-1-Alpha-2'];
        const stats = countryStats[code];
        if (stats) {
            const winRate = (stats.wins / stats.totalRounds * 100).toFixed(1);
            layer.bindPopup(`<strong>${stats.name}</strong><br>Win Rate: ${winRate}%<br>Rounds: ${stats.totalRounds}`);
        }
    });
}


function getColorForFeature(feature) {
    const code = feature.properties['ISO3166-1-Alpha-2'];
    if (!code || !countryStats[code]) return '#e9ecef';
    const winRate = countryStats[code].wins / countryStats[code].totalRounds * 100;
    return winRate > 70 ? '#1a9641' : winRate > 60 ? '#a6d96a' : winRate > 50 ? '#ffffbf' : winRate > 40 ? '#fdae61' : '#d7191c';
}

function getGameMode(movementOptions) {
    if (!movementOptions) return 'moving';
    if (movementOptions.forbidMoving && movementOptions.forbidZooming) return 'nmpz';
    if (movementOptions.forbidMoving) return 'nomove';
    return 'moving';
}

function showError(message) {
    document.getElementById('dashboard-container').classList.add('d-none');
    const e = document.getElementById('error-container');
    e.classList.remove('d-none');
    e.innerHTML = `<div class="alert alert-warning">${message}</div>`;
}

function getFlagEmoji(countryCode) {
    if (!countryCode || countryCode.length !== 2 || countryCode === '-9') return 'üè¥‚Äç‚ò†Ô∏è';
    return String.fromCodePoint(...countryCode.toUpperCase().split('').map(char => 127397 + char.charCodeAt()));
}

</script>



</body>
</html>

